/** loom
  *
  * Copyright (c) 2016 Hugo Firth
  * Email: <me@hugofirth.com/>
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at:
  *
  * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
package org.gdget.loom

import java.nio.file.{Files, Paths}

import language.higherKinds
import cats._
import cats.implicits._
import jawn.ast
import jawn.AsyncParser
import jawn.ParseException
import jawn.ast.JValue

import scala.annotation.tailrec
import scala.io.Source

/** Dumb container for `import` method at the moment, though have the feeling this could be significantly more
  * intelligent.
  *
  *
  * @author hugofirth
  */
object GraphReader {

  //Use Jawn to read in JSON generated by neo4j-exporter

  //Spit into LogicalParGraph - how efficient is constructor? Use internal buffer?

  def read[B](path: String, toInput: JValue => Either[String, B]): Either[ParseException, Stream[B]] = {
    //Load the file lazily given path
    val input = Paths.get(path)
    val p = ast.JParser.async(mode = AsyncParser.UnwrapArray)
    val vertexStream: Iterator[String] = Source.fromFile(input.toFile).getLines()

    @tailrec
    def go(js: Iterator[String], inputStream: Stream[B], line: Int): Either[ParseException, Stream[B]] = {
      if (js.hasNext)
        p.absorb(js.next()) match {
          case Right(entries) =>
            entries.toStream.traverse(toInput) match {
              case Right(bStream) =>
                go(js, bStream #::: inputStream, line + 1)
              case Left(errorMsg) =>
                Left(ParseException(errorMsg, -1, line, -1))
            }
          case Left(e) =>
            Left(e)
        }
      else
        p.finish().flatMap { entries =>
          entries.toStream.traverse(toInput) match {
            case Right(bStream) =>
              Right(bStream #::: inputStream)
            case Left(errorMsg) =>
              Left(ParseException(errorMsg, -1, line, -1))
          }
        }
    }

    go(vertexStream, Stream.empty[B], 0)
  }

}
