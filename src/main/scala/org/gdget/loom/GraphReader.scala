/** loom
  *
  * Copyright (c) 2016 Hugo Firth
  * Email: <me@hugofirth.com/>
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at:
  *
  * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
package org.gdget.loom

import java.nio.file.{Files, Paths}

import language.higherKinds
import org.gdget.Edge
import org.gdget.partitioned.{LogicalParGraph, Partitioned, Partitioner}
import jawn.ast
import jawn.AsyncParser
import jawn.ParseException
import jawn.ast.JValue

import scala.io.Source

/** Dumb container for `import` method at the moment, though have the feeling this could be significantly more
  * intelligent.
  *
  *
  * @author hugofirth
  */
object GraphReader {

  //Use Jawn to read in JSON generated by neo4j-exporter

  //Spit into LogicalParGraph - how efficient is constructor? Use internal buffer?

  //TODO: Switch to using Xor

  def read[B](path: String, toInput: JValue => B): Either[ParseException, Stream[B]] = {
    //Load the file lazily given path
    val input = Paths.get(path)
    val p = ast.JParser.async(mode = AsyncParser.UnwrapArray)
    val vertexStream: Iterator[String] = Source.fromFile(input.toFile).getLines()

    def go(js: Iterator[String], inputStream: Stream[B]): Either[ParseException, Stream[B]] = {
      if(js.hasNext)
        p.absorb(js.next()) match {
          case Right(entries) =>
            //TODO: Do extra work here, possible have Parse function return trie and go Left if it fails
            go(js, entries.map(toInput).toStream #::: inputStream)
          case Left(e) =>
            Left(e)
        }
      else p.finish().right.map(_.map(toInput).toStream #::: inputStream)
    }

    go(vertexStream, Stream.empty[B])
  }

}
